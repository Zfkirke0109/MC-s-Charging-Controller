#!/sbin/sh
# MC's Charging Controller
# mcc update-binary ( 201801231 )
# MCMotherEffin' @ XDA Developers

if (grep -q ^/sbin/sh /proc/$$/cmdline); then

  # Abort if recovery installation
  ## we parse uevents for boot mode only
  fd=/proc/self/fd/$2

  ui_print() { echo -e "ui_print $1\nui_print" >>$fd; }

  ui_print ' '; ui_print ' ';
  ui_print '- Abort :- Please install in boot mode'
  ui_print ' '; ui_print ' ';
  exit 1
fi
echo ' '

# Define variables
zip_file="$3"
tmp_file=/dev/mcc_tmp/file
mount_path=/dev/mcc_img
mod_dir=$mount_path/mcc

# Define functions

abort() { echo -e "- Abort :- $1\n"; exit 1; }

# Set busybox up
magisk_bb=$(find /data -type f -name busybox | grep /magisk/busybox$)
if [ ! -x "$magisk_bb" ]; then
  echo -e "- Error :- Could not find Magisk internal busybox\n"
  abort 'Please install Magisk v14.0+'
fi
for func in $($magisk_bb --list); do
  alias $func="$magisk_bb $func"
done
image=${magisk_bb%/*/*}/magisk_merge.img

# Get the system for A / B device
system=/system
if [[ -d /system_root ]]; then
  system=/system_root/system
fi

# Detect Magisk mount point
for loop_device in /dev/block/loop*; do
  if (losetup $loop_device | grep -q ${image%/*}/magisk.img); then
    for mount_point in $(grep "$loop_device " /proc/mounts | awk '{print $2}' | grep -v ^$system); do
      if (grep -q com.google.android.gms.unstable $mount_point/.core/hidelist); then
        break 2
      fi
      unset mount_point
    done
  fi
done
if [[ -z $mount_point ]]; then
  abort 'Could not find Magisk mount point'
fi
main_mod_dir=$mount_point/mcc

# Print module name
echo -e "------------------------------------------------\n"
echo -e "     MC's Charging Controller\n"
echo -e "         by MCMotherEffin' @ XDA Developers\n"
echo -e "------------------------------------------------\n"

# Test compatibility and set references
## see the Main Script for documentation
echo -e "- Please make sure the device is charging\n"
sleep 5
echo -e "- Checking compatibility...\n"
mkdir ${tmp_file%/*}
find /sys/devices -type f -name uevent | grep -Ei 'batt|charg' >$tmp_file

is_charging() { grep -q =[Cc]harging$ $uevent; }

while read uevent; do
  if (grep -q ^POWER_SUPPLY_.*=.*[Bb]att.*$ $uevent); then
    i=0
    for ref in ${uevent%/*}/*; do
      if [[ ! -f $ref ]]; then continue; fi
      chown 0:0 $ref; chmod 644 $ref;
      case $(cat $ref) in
        1       )
          echo 0 >$ref
          c_ON=1; c_OFF=0;              ;;
        0       )
          echo 1 >$ref
          c_ON=0; c_OFF=1;              ;;
        on      )
          echo off >$ref
          c_ON=on; c_OFF=off;           ;;
        off     )
          echo on >$ref
          c_ON=off; c_OFF=on;           ;;
        true    )
          echo false >$ref
          c_ON=true; c_OFF=false;       ;;
        false   )
          echo true >$ref
          c_ON=false; c_OFF=true;       ;;
        enable  )
          echo disable >$ref
          c_ON=enable; c_OFF=disable;   ;;
        disable )
          echo enable >$ref
          c_ON=disable; c_OFF=enable;   ;;
        enabled )
          echo disabled >$ref
          c_ON=enabled; c_OFF=disabled; ;;
        disabled)
          echo enabled >$ref
          c_ON=disabled; c_OFF=enabled; ;;
        *       )
          continue                      ;;
      esac; sleep 0.2
      if (! is_charging); then
        echo $c_ON >$ref; sleep 0.2;
        if (is_charging); then
          switches[i]="$ref $c_ON $c_OFF"
          ((i += 1))
          if [[ $i -eq 4 ]]; then break 2; fi
        fi
      fi
      echo $c_ON >$ref
    done
    if [[ $i -gt 0 ]]; then break; fi
  fi
done <$tmp_file
rm -rf ${tmp_file%/*}
if [[ $i -eq 0 ]]; then
  abort "Your device don't support these functionalities"
fi
echo -e "- OK\n"

# Resize or create image for installation
if [[ -f $image ]]; then
  echo -e "- Found $image\n"

  imgsize_test() {
    e2fsck -n $image | grep -Eo '[0-9]+/[0-9]+ blocks' | cut -d/ -f$1 | awk '{print int($1 / 256)}'
  }

  img_used=$(($(imgsize_test 1) + 1))
  img_total=$(imgsize_test 2)
  if [[ $img_used -eq $img_total ]]; then
    echo -e "- Expanding $image...\n"
    resize2fs $image $((img_total + 64))M
  fi
else
  echo -e "- Creating $image...\n"
  make_ext4fs -l 64M $image >&2
fi

is_mounted() { grep -q " $mount_path " /proc/mounts; }

# Mount the image
echo -e "- Mounting $image...\n"
mkdir $mount_path
for loop in 0 1 2 3 4 5 6 7; do
  loop_device=/dev/block/loop$loop
  if [[ ! -b $loop_device ]]; then
    mknod $loop_device b 7 $loop
  fi
  if (losetup $loop_device $image); then
    mount -t ext4 -o loop $loop_device $mount_path
  fi
  if (is_mounted); then break; fi
done
if (! is_mounted); then
  abort "Could not mount $image"
fi

get_prop() { sed -n s/^$1=//p $2; }

# Get current version code
cur_ver_code=$(get_prop versionCode $mod_dir/module.prop || get_prop versionCode $main_mod_dir/module.prop || echo 0)

# Detect whether to install / uninstall
if [[ $cur_ver_code -ge 201801231 ]]; then

  # Uninstall
  echo -e "- Same or newer already installed\n"
  echo -e "- Attention :- Uninstalling...\n"
  rm -rf $mod_dir $main_mod_dir
else

  # Install

  # Create all needed directories
  rm -rf $mod_dir
  mkdir -p $mod_dir/docs; mkdir $mod_dir/cache
  

  # Extract module files
  echo -e "- Extracting module files...\n"
  unzip -o "$zip_file" 'system/*' mcc.conf service.sh module.prop -d $mod_dir >&2
  unzip -o "$zip_file" LICENSE.md README.md -d $mod_dir/docs >&2
  bin_dir=$mod_dir/system/xbin
  if [[ ! -d $system/xbin ]]; then
    mv $bin_dir $mod_dir/system/bin
    bin_dir=$mod_dir/system/bin
  fi

  set_prop() { sed -i "s|^$1=.*|$1=$2|g" $mod_dir/mcc.conf; }

  old_conf=$main_mod_dir/data/settings.conf
  if [[ -f $old_conf ]]; then

    # Restore settings
    echo -e "- Restoring settings...\n"
    for prop in auto_shut daemon_mode up_threshold down_threshold shut_threshold; do
      set_prop $prop $(get_prop $prop $old_conf)
    done
  fi

  # Set uevent and switches in settings.conf
  set_prop uevent $uevent
  for i in 0 1 2 3; do
    case ${switches[i]} in
      '')
        break
      ;;
      * )
        set_prop switch_$((i + 1)) "${switches[i]}"
      ;;
     esac
  done

  # Enable magic mount
  touch $mod_dir/auto_mount

  # Update info for Magisk Manager
  mkdir $main_mod_dir
  touch $main_mod_dir/update
  cp -f $mod_dir/module.prop $main_mod_dir

  set_perm_recursive() {
    find $1 | while read entry; do
      chown $2:$3 $entry
      if [[ -f $entry ]]; then
        chmod $4 $entry
      else
        chmod $5 $entry
      fi
      chcon u:object_r:system_file:s0 $entry
    done
  }

  # Set permissions
  echo -e "- Setting permissions...\n"
  set_perm_recursive $mod_dir 0 0 0644 0755
  set_perm_recursive $bin_dir 0 2000 0755 0755
fi

# Unmount the image, and yippeee...
umount $mount_path; losetup -d $loop_device;
rmdir $mount_path
echo -e "- Done\n"
exit 0
