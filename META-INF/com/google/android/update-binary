#!/sbin/sh
# MC's Charging Controller (mcc)
# mcc update-binary ( shell edify replacement )
# versionCode = 201712272
# MCMotherEffin' @ XDA Developers

# Detect whether in boot mode

if ! (ps | grep 'zygote' | grep -qv 'grep'); then
  boot_mode=false

  if (ps -A 2>/dev/null | grep 'zygote' | grep -qv 'grep'); then
    boot_mode=true
  fi
else
  boot_mode=true
fi

# Abort if recovery installation

if ! ($boot_mode); then

  output_fd=$2
  ui_print() {
    echo -e "ui_print $1\nui_print" >>/proc/self/fd/$output_fd
  }

  ui_print " "
  ui_print "(!) Please install in boot mode"
  ui_print " "
  exit 1
fi

echo " "

# Define universal variables

zip_file="$3"
tmp_dir=/dev/tmpdir_mcc
tmp_file=$tmp_dir/tmp_file
mount_path=/dev/magisk_img_mcc
mod_path=$mount_path/mcc
image=/data/magisk_merge.img

# Define universal functions

error() { echo -e "(!) $1\n"; exit 1; }

get_prop() { sed -n s/^$1=//p $2; }

set_prop() { sed -i "s|$1=.*|$1=$2|g" $mod_path/data/settings.conf; }

is_mounted() { grep -q " $1 " /proc/mounts; }

is_charging() { grep -q '^POWER_SUPPLY_STATUS=[Cc]harging$' $uevent; }

set_dir_perms() {
  find $1 2>/dev/null | while read entry; do
    chown $2:$3 $entry
    if [[ -f $entry ]]; then
      chmod $4 $entry
    else
      chmod $5 $entry
    fi
    chcon u:object_r:system_file:s0 $entry
  done
}

image_test() {
  blocks=$(e2fsck -n $image | grep -Eo '[0-9]+/[0-9]+ blocks' | cut -d/ -f$1 | awk '{print $1}')
  echo $((blocks / 256))
}

# Set BusyBox up

magisk_bb=$(find /data -type f -name busybox | grep '/magisk/busybox$')
if [ ! -x "$magisk_bb" ]; then
  echo -e "(!) Could not find MAGISK internal BusyBox\n"
  error "Please install MAGISK v14.0+"
fi

for func in $($magisk_bb --list); do
  alias $func="$magisk_bb $func"
done

# Detect whether A / B device

if [[ -d /system_root ]]; then
  system=/system_root/system
else
  system=/system
fi

# Detect MAGISK mount point

for loop_device in /dev/block/loop*; do
  if (losetup $loop_device | grep -q '/data/.*magisk.img'); then
    for mount_point in $(grep "$loop_device " /proc/mounts | awk '{print $2}' | grep -v "^$system"); do
      if [[ ! -z $mount_point ]]; then
        if [[ -f $mount_point/.core/hidelist ]]; then
          if [[ -d $mount_point/.core/service.d ]]; then
            break 2
          fi
        fi
      fi
      unset mount_point
    done
  fi
done

if [[ ! -z $mount_point ]]; then
  main_mod_path=$mount_point/mcc
else
  error "Could not find MAGISK mount point"
fi

# Print module name

echo -e "------------------------------------------------\n"
echo -e "     MC's Charging Controller (mcc)\n"
echo -e "         by MCMotherEffin' @ XDA Developers\n"
echo -e "------------------------------------------------\n"

# Test compatibility and set references
# ( device must be charging throughout )
# ( see the Main Script for documentation )

echo -e "(!) Please make sure the device is charging\n"
sleep 5

echo -e "(i) Checking compatibility...\n"

mkdir $tmp_dir
find /sys/devices -type f -name uevent 2>/dev/null | grep -E 'batt|charg' | sort >$tmp_file

while read uevent; do
  if (grep -q '^POWER_SUPPLY_NAME=.*[Bb]att.*$' $uevent) \
  || (grep -q '^POWER_SUPPLY_NAME=.*[Uu][Ss][Bb].*$' $uevent) \
  || (grep -q '^POWER_SUPPLY_NAME=.*[Dd][Cc].*' $uevent); then

    i=0
    for ref in ${uevent%/*}/*; do
      if [[ -f $ref ]]; then
      chown 0:0 $ref; chmod 644 $ref;
      else continue; fi

      case $(cat $ref) in
        1) echo 0 >$ref
          c_ON=1; c_OFF=0;              ;;

        0) echo 1 >$ref
          c_ON=0; c_OFF=1;              ;;

        on) echo off >$ref
          c_ON=on; c_OFF=off;           ;;

        off) echo on >$ref
          c_ON=off; c_OFF=on;           ;;

        true) echo false >$ref
          c_ON=true; c_OFF=false;       ;;

        false) echo true >$ref
          c_ON=false; c_OFF=true;       ;;

        enable) echo disable >$ref
          c_ON=enable; c_OFF=disable;   ;;

        disable) echo enable >$ref
          c_ON=disable; c_OFF=enable;   ;;

        enabled) echo disabled >$ref
          c_ON=enabled; c_OFF=disabled; ;;

        disabled) echo enabled >$ref
          c_ON=disabled; c_OFF=enabled; ;;

        *) continue                     ;;
      esac; sleep 0.2
      if ! (is_charging); then
        echo $c_ON >$ref; sleep 0.2;
        if (is_charging); then
          switches[i]="$ref $c_ON $c_OFF"
          ((i += 1)); if [[ $i -eq 3 ]]; then
          break 2
          fi
        fi
      fi
      echo $c_ON >$ref
    done
    if [[ $i -gt 0 ]]; then break; fi
  fi
done <$tmp_file

if [[ $i -gt 0 ]]; then
  echo -e "- OK\n"
else
  error "Your kernel don't support this functionalities"
fi

# Get the image ready for installation

if [[ -f $image ]]; then
  echo -e "(i) $image exists\n"

  image_used=$(image_test 1)
  image_total=$(image_test 2)
  image_free=$((image_total - image_used))

  if [[ ! $image_free -gt 1 ]]; then
    image_size_new=$(((image_used + 1) / 32 * 32 + 64))
    echo -e "(i) Resizing $image to ${image_size_new}M...\n"
    resize2fs $image ${image_size_new}M
  fi
else

  echo -e "(i) Creating $image of 64M...\n"
  make_ext4fs -l 64M $image >/dev/null
fi

# Mount the image

echo -e "(i) Mounting $image to $mount_path...\n"

mkdir $mount_path
for loop in 0 1 2 3 4 5 6 7; do
  loop_device=/dev/block/loop$loop

  if [[ ! -f $loop_device && ! -b $loop_device ]]; then
    mknod $loop_device b 7 $loop
  fi
  if (losetup $loop_device $image); then
    mount -t ext4 -o loop $loop_device $mount_path
  fi
  if (is_mounted $mount_path); then break; fi
done
if ! (is_mounted $mount_path); then
  error "Could not mount $image"
fi

# Detect whether installed or not

if [[ -f $mod_path/module.prop ]]; then
  cur_ver_code=$(get_prop versionCode $mod_path/module.prop)

elif [[ -f $main_mod_path/module.prop ]]; then
  cur_ver_code=$(get_prop versionCode $main_mod_path/module.prop)

else
  cur_ver_code=0
fi

# Unzip module.prop, for flash again to uninstall

unzip -oq "$zip_file" module.prop -d $tmp_dir
if [[ ! -f $tmp_dir/module.prop ]]; then
  umount $mount_path; losetup -d $loop_device;
  error "Could not extract zip file"
fi

if [[ $(get_prop versionCode $tmp_dir/module.prop) -le $cur_ver_code ]]; then

  # Uninstall

  echo -e "(i) Same or older detected\n"
  echo -e "(!) Uninstalling...\n"
  rm -rf $mod_path $main_mod_path 2>/dev/null
else

  # Install

  # Preserve old settings

  old_conf=$main_mod_path/data/settings.conf
  if [[ -f $old_conf ]]; then
    echo -e "(i) Backing up old settings...\n"

    set_1=$(get_prop ver_logs $old_conf)
    set_2=$(get_prop auto_shut $old_conf)
    set_3=$(get_prop daemon_mode $old_conf)
    set_4=$(get_prop up_threshold $old_conf)
    set_5=$(get_prop down_threshold $old_conf)
    set_6=$(get_prop shut_threshold $old_conf)
  fi

  # Clean module path up

  rm -rf $mod_path 2>/dev/null
  mkdir $mod_path

  # Copy files

  echo -e "(i) Copying module files...\n"
  unzip -oq "$zip_file" 'system/*' -d $mod_path

  zip_bin=true
  case $(get_prop ro.product.cpu.abi $system/build.prop) in

  arm*)  unzip -oq "$zip_file" zip_arm -d $mod_path               ;;
  x86*)  unzip -oq "$zip_file" zip_x86 -d $mod_path               ;;
  *   )  zip_bin=false  ;;
  esac

  if ($zip_bin); then
    mv -f $mod_path/zip* $mod_path/zip
  fi

  unzip -oq "$zip_file" 'data/*' -d $mod_path
  unzip -oq "$zip_file" README.md -d $mod_path/data

  # Set preserved settings

  if [[ ! -z $set_1 ]]; then
    echo -e "(i) Restoring old settings...\n"

    set_prop ver_logs $set_1
    set_prop auto_shut $set_2
    set_prop daemon_mode $set_3
    set_prop up_threshold $set_4
    set_prop down_threshold $set_5
    set_prop shut_threshold $set_6
  fi

  # Set new tested settings for this

  set_prop uevent $uevent
  for i in 0 1 2; do

    if [[ ${switches[i]} ]]; then
      set_prop switch_$((i + 1)) "${switches[i]}"
    else
      break
    fi
  done

  # Auto mount

  touch $mod_path/auto_mount

  # Module info

  cp -f $tmp_dir/module.prop $mod_path

  # Update info for Magisk Manager

  mkdir $main_mod_path 2>/dev/null
  touch $main_mod_path/update
  chmod 644 $main_mod_path/update
  cp -f $tmp_dir/module.prop $main_mod_path

  # Service mode scripts

  unzip -oq "$zip_file" service.sh -d $mod_path

  echo -e "(i) Setting permissions...\n"

  set_dir_perms $mod_path 0 0 644 755
  set_dir_perms $mod_path/system/bin 0 2000 755 755
  if ($zip_bin); then
    zip_bin=$mod_path/zip
    chown 0:2000 $zip_bin
    chmod 755 $zip_bin
    chcon u:object_r:system_file:s0 $zip_bin
  fi
fi

umount $mount_path; losetup -d $loop_device;
rmdir $mount_path

# Clean temporary files

rm -rf $tmp_dir

echo -e "- Done\n"
exit 0
