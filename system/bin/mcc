#!/system/bin/sh
# MC's Charging Controller (mcc)
# mcc Main Script
# versionCode = 2017122203
# MCMotherEffin' @ XDA Developers

# Initial verbose logger ( can't be toggled )

    set -x 2>/cache/mcc_debug_init.log

# Detect whether root

if ! (id | grep -iq 'uid=0'); then
  echo -e "\n(!) mcc musta be root\n"
  exit 1
else
  echo " "
fi

# Setup BusyBox

for magisk_bb in $(find /data -type f -name busybox); do
  if (echo $magisk_bb | grep -q '/magisk/busybox$'); then
    alias busybox=$magisk_bb
    break
  fi
  unset magisk_bb
done
if [ -z $magisk_bb ]; then
  if ! (busybox >/dev/null); then
    echo -e "(!) Please install BusyBox ( osm0sis' recommended )\n"
    exit 1
  fi
fi
for func in $(busybox --list); do
  alias $func="busybox $func"
done

# Detect whether A/B device

if [[ -d /system_root ]]; then
  system=/system_root/system
else
  system=/system
fi

# Detect MAGISK mountpoint

for loop in /dev/block/loop*; do
  if (losetup $loop | grep -q '/magisk.img$'); then
    for mountpoint in $(grep "$loop " /proc/mounts | awk '{print $2}' | grep -v "^$system"); do
      if [[ ! -z $mountpoint ]]; then
        if [[ -f $mountpoint/.core/hidelist ]]; then
          if [[ -d $mountpoint/.core/service.d ]]; then
            break 2
          fi
        fi
      fi
      unset mountpoint
    done
  fi
done

if [[ ! -z $mountpoint ]]; then
  mod_dir=$mountpoint/mcc
else
  echo -e '(!) MAGISK mountpoint not found\n'
  exit 1
fi

# All variables are defined here

data_dir=$mod_dir/data
config=$data_dir/settings.conf
ver_log=$data_dir/verbose.log
last_log=$data_dir/last_ver.log
sys_cache=$data_dir/sys_cache.tmp

# All functions are defined here

error() {  echo -e "(!) $1\n"; exit 1;  }

get_prop() {
  if [[ ! -z $2 ]]; then
    prop_file=$2
  else
    prop_file=$config
  fi
  sed -n s/^$1=//p $prop_file
}

set_prop() {
  if [[ ! -z $3 ]]; then
    prop_file=$3
  else
    prop_file=$config
  fi
  sed -i "s|^$1=.*|$1=$2|g" $prop_file
}

test_level() {
  if (echo $1 | grep -Eq '^[0-9]+$'); then
    if [[ $1 -lt 0 || $1 -gt 100 ]]; then
      error "$1 is not between 0-100"
    fi
  else
    error "$1 is not a number"
  fi
}

test_diff() {
  if [[ ! $1 -gt $(($2 + 5)) ]]; then
    error "Please use [ --keep ] [ KEEP % ] for this"
  fi
}

toggle() {
  if ($($1)); then
    value=false; status=OFF;
  else
    value=true; status=ON;
  fi
  echo -e "(i) Toggling $2 $status...\n"
  set_prop $1 $value
  echo -e "- Done\n"
}

set_switch() {
  set_prop switch "$1 $2 $3"
  chown 0:0 $1
  chmod 644 $1
  uevent_=${1%/*}/uevent
  set_prop uevent $uevent_
  chown 0:0 $uevent_
  chmod 444 $uevent_
}

switch_() {
  switch=$(get_prop switch)
  c_ON=$(echo $switch | awk '{print $2}')
  c_OFF=$(echo $switch | awk '{print $3}')
  switch=$(echo $switch | awk '{print $1}')
  
  if [[ $1 = ON ]]; then
    echo $c_ON >$switch
  else
    echo $c_OFF >$switch
  fi
}

override_daemon() {
  if ($(daemon_mode)); then
    mcc --daemon >/dev/null
    echo -e "(!) Daemon mode overridden\n"
  fi
}

update_cfg() {
  if [[ ! -z $1 && ! -z $2 ]]; then
    if [[ $1 -ge 15 && $2 -ge 15 ]]; then
      if [[ $1 -le 85 && $2 -le 85 ]]; then
        u=$1; d=$2;
      else gerror=true;
      fi
    else gerror=true;
    fi
  elif [[ ! -z $1 && -z $2 ]]; then
    if [[ $1 -ge 30 ]]; then
      if [[ $1 -le 85 ]]; then
        u=$1; d=$((u - 15));
      else gerror=true;
      fi
    else gerror=true;
    fi
  elif [[ -z $1 ]]; then
    u=80; d=60;
  fi

  if [[ $gerror ]]; then
    error "These value/values affect battery life"
  fi
  set_prop up_threshold $u
  set_prop down_threshold $d
  echo -e "- New settings saved\n"
}

is_charging() { grep -q '_STATUS=[Cc]harging$' $(uevent_f); }

uevent_f() { get_prop uevent; }

switch_f() { get_prop switch; }

daemon_mode() { get_prop daemon_mode; }

do_ver_logging() { get_prop do_ver_logging; }

batt_level() { get_prop POWER_SUPPLY_CAPACITY $(uevent_f); }

up_threshold() { get_prop up_threshold; }

down_threshold() { get_prop down_threshold; }

# This zips debug data in /sdcard

debug() {
  echo -e "(i) Gathering debugging data...\n"
  debug_zip=/cache/mcc_debug-"$(getprop ro.product.brand)-$(getprop ro.product.device)".zip
  rm -f "$debug_zip"

  $mod_dir/zip -9q "$debug_zip" /cache/mcc_debug_init.log
  for entry in $(find $mod_dir ! -type d); do
    if [[ $entry != $mod_dir/zip ]]; then
      $mod_dir/zip -9qu "$debug_zip" $entry
    fi
  done

  echo -e "- Done\n"
  echo -e "(!) Please upload $debug_zip to the official XDA thread\n"
}

# This tests and sets references if compatible
# ( device must be charging throughout )

set_ctrl_refs() {
  refs_found=false
  echo -e "(!) Please make sure the device is charging\n"
  sleep 3
  echo -e "(i) Checking compatibility...\n"
  if [[ ! -f $sys_cache ]]; then
    find /sys/devices ! -type d ! -name *.log 2>/dev/null | grep -E 'batt|charg' | sort >$sys_cache
  fi

  for uevent_ in $(grep '/uevent$' $sys_cache); do
    if (grep -q '^POWER_SUPPLY_NAME=.*[Bb]att.*$' $uevent_) \
    || (grep -q '^POWER_SUPPLY_NAME=.*[Uu][Ss][Bb].*$' $uevent_) \
    || (grep -q '^POWER_SUPPLY_NAME=.*[Dd][Cc].*' $uevent_); then
      set_prop uevent $uevent_

      for ref_ in ${uevent_%/*}/*; do

        cont=$(cat $ref_)
        case $cont in
          1) echo 0 >$ref_
            c_ON=1; c_OFF=0; ;;

          0) echo 1 >$ref_
            c_ON=0; c_OFF=1; ;;

          on) echo off >$ref_
            c_ON=on; c_OFF=off; ;;

          off) echo on >$ref_
            c_ON=off; c_OFF=on; ;;

          true) echo false >$ref_
            c_ON=true; c_OFF=false; ;;

          false) echo true >$ref_
            c_ON=false; c_OFF=true; ;;

          enable) echo disable >$ref_
            c_ON=enable; c_ON=disable; ;;

          disable) echo enable >$ref_
            c_ON=disable; c_OFF=enable; ;;

          enabled) echo disabled >$ref_
            c_ON=enabled; c_OFF=disabled; ;;

          disabled) echo enabled >$ref_
            c_ON=disabled; c_OFF=enabled; ;;

          *) continue ;;
        esac
        sleep 0.2
        if ! (is_charging); then
          set_switch $ref_ $c_ON $c_OFF
          switch_ ON; sleep 0.2;
          if (is_charging); then
            refs_found=true
            break 2
          fi
        fi
      done
    fi
  done

  if ($refs_found); then
    echo -e "- OK\n"
  else
    set_switch not_found_yet 1 0
    set_prop uevent not_found_yet
    error "Your kernel don't support this functionality"
  fi
}

# Function for [ --start / --stop ] [ % / time ]

charge() {
  if [[ $1 = start ]]; then
    turn_1=ON; turn_2=OFF; op=-lt; text=Charging; test='! is_charging';
  else
    turn_1=OFF; turn_2=ON; op=-gt; text=Discharging; test='is_charging';
  fi
  if [[ ! -z $2 ]]; then
    if (echo $2 | grep -Eq '^[0-9]+%$'); then
      threshold=$(echo $2 | tr -d '%')
      if [[ $threshold -lt 0 || $threshold -gt 100 ]]; then
        error "Please give a level between 0-100 %"
      fi
      override_daemon
      if (eval $test); then
        switch_ $turn_1
      fi
      echo -e "(i) $text until $threshold%...\n"
      while eval [[ \$\(batt_level\) $op \$threshold ]]; do
        if (eval $test); then
          switch_ $turn_1
        fi
        sleep 30
      done
      switch_ $turn_2
    elif (echo $2 | grep -Eq '^[0-9]+[smh]?$'); then
      override_daemon
      if (eval $test); then
        switch_ $turn_1
      fi
      echo -e "(i) $text until $2...\n"
      sleep $2
      switch_ $turn_2
    else
      error "Please give a valid argument"
    fi
  else
    override_daemon
    if (eval $test); then
      switch_ $turn_1
    fi
    echo -e "(i) $text now...\n"
  fi
}

# Disable logger

    set +x

# Verbose logger

if ($(do_ver_logging)); then
  if [[ $1 != --log ]]; then
    if [[ ! $no_logging ]]; then
      if [[ -f $ver_log ]]; then
        mv -f $ver_log $last_log
      fi
      echo -e "(!) Verbose logging is enabled\n"
      getprop | grep 'product' >$ver_log
      echo -e "\nmcc_version=$(get_prop versionCode $mod_dir/module.prop)\n" >>$ver_log
      set -x 2>>$ver_log
    fi
  fi
fi

# Set control references unless done

if [[ $(uevent_f) = not_found_yet ]]; then
  case $1 in
    --log            ) ;;
    --help           ) ;;
    --rconf          ) ;;
    --debug          ) ;;
    --breset         ) ;;
    --daemon_trigger ) ;;
    *                ) set_ctrl_refs ;;
  esac
fi

case $1 in

## info

  --info)
    echo -e "- Battery status\n"
    echo "-- battery level :- $(batt_level)"
    echo "-- battery health :- $(get_prop POWER_SUPPLY_HEALTH $(uevent_f))"
    echo -e "-- charging status :- $(get_prop POWER_SUPPLY_STATUS $(uevent_f))\n"
    echo -e "- Current settings\n"
    echo "-- up threshold :- $(up_threshold)"
    echo "-- down threshold :- $(down_threshold)"
    echo -e "-- magisk daemon mode :- $(daemon_mode)\n"
      ;;

## manpage

  --help)
    cat $data_dir/README.md
      ;;

## re-test and configure kernel references

  --rconf)
    echo -e "(i) Re-configuring kernel references...\n"
    set_ctrl_refs 2>/dev/null
    echo -e "- Done\n"
      ;;

## debugging on demand, output in /cache

  --debug) debug 2>/dev/null
      ;;

## remove battery stats

  --breset)
    echo -e "(i) Resetting battery statistics...\n"
    rm -f /data/system/batterystats.bin
    echo -e "- Done\n"
      ;;

## toggle verbose logging

  --log)
    toggle do_ver_logging "verbose logging"
      ;;

## toggle daemon mode

  --daemon)
    toggle daemon_mode "daemon mode"
      ;;

## keep battery level at certain level

  --keep)
    test_level $2
    override_daemon
    if ! (is_charging); then
      switch_ ON
    fi
    echo -e "(i) Battery level will be kept at $2%\n"
    while(:); do
      if [[ $(batt_level) -lt $2 ]]; then
        if ! (is_charging); then
          switch_ ON
        fi
      elif [[ $(batt_level) -gt $2 ]]; then
        if (is_charging); then
          switch_ OFF
        fi
      fi
      sleep 30
    done
      ;;

## enable charging (on demand/for certain %/time)

  --start)
    charge start $2
      ;;

## disable charging (on demand/for certain %/time)

  --stop)
    charge stop $2
      ;;

## trigger daemon ( MAGISK )

  --daemon_trigger)
    while(:); do
      if ($(daemon_mode)); then
        if [[ $(batt_level) -gt $(up_threshold) ]]; then
          if (is_charging); then
            switch_ OFF
          fi
        elif [[ $(batt_level) -lt $(down_threshold) ]]; then
          if ! (is_charging); then
            switch_ ON
          fi
        fi
      fi
      sleep 30
    done
      ;;

## update previous thresholds

  *)
    if [[ $# -eq 1 || $# -eq 2 ]]; then
      if [[ ! -z $2 ]]; then
        test_level $2
      fi
      test_level $1
      if [[ $2 -eq $1 ]]; then
        error "Please don't give same levels"
      fi
      if [[ $2 && $2 -gt $1 ]]; then
        test_diff $2 $1
        update_cfg $2 $1
      else
        test_diff $1 $2
        update_cfg $1 $2
      fi
      if ! ($(daemon_mode)); then
        mcc --daemon >/dev/null
        echo -e "(!) Daemon mode toggled ON\n"
      fi
    else
      error "Either less or more arguments given"
    fi
      ;;

esac
exit 0
