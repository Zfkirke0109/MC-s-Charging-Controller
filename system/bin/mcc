#!/system/bin/sh
# MC's Charging Controller (mcc)
# mcc Main Script
# versionCode = 201712253
# MCMotherEffin' @ XDA Developers

# Initial verbose logger ( can't be toggled )

    set -x 2>/cache/mcc_debug_init.log

# Detect whether root

if ! (id | grep -iq 'uid=0'); then
  echo -e "\n(!) Please run \"mcc $@\" as root\n"
  exit 1
else
  echo " "
fi

# Setup BusyBox

bb=$(find /data -type f -name busybox | grep '/magisk/busybox$')
if [ -x "$bb" ]; then alias busybox=$bb; fi

if ! (busybox >/dev/null); then
  echo -e "(!) Please install BusyBox ( osm0sis' recommended )\n"
  exit 1
fi

for func in $(busybox --list); do
  alias $func="busybox $func"
done

# Detect whether A / B device

if [[ -d /system_root ]]; then
  system=/system_root/system
else
  system=/system
fi

# Detect MAGISK mountpoint

for loop in /dev/block/loop*; do
  if (losetup $loop | grep -q '/data/.*magisk.img'); then

    for mountpoint in $(grep "$loop " /proc/mounts | awk '{print $2}' | grep -v "^$system"); do
      if [[ ! -z $mountpoint ]]; then
        if [[ -f $mountpoint/.core/hidelist ]]; then
          if [[ -d $mountpoint/.core/service.d ]]; then
            break 2
          fi
        fi
      fi
      unset mountpoint
    done
  fi
done

if [[ ! -z $mountpoint ]]; then
  mod_dir=$mountpoint/mcc
else
  echo -e '(!) Could not find MAGISK mountpoint\n'
  exit 1
fi

# All variables are defined here

data_dir=$mod_dir/data
config=$data_dir/settings.conf
ver_log=$data_dir/verbose.log
last_log=$data_dir/last_ver.log
sys_cache=$data_dir/sys_cache.tmp

# All functions are defined here

## yields an error and exits 1

error() { echo -e "(!) $1\n"; exit 1; }

## gets a property from a propfile

get_prop() {
  if [[ ! -z $2 ]]; then
    prop_file=$2
  else
    prop_file=$config
  fi
  sed -n s/^$1=//p $prop_file
}

## sets a property in a propfile

set_prop() {
  if [[ ! -z $3 ]]; then
    prop_file=$3
  else
    prop_file=$config
  fi
  sed -i "s|^$1=.*|$1=$2|g" $prop_file
}

## tests if the argument is a battery level

test_level() {
  if (echo $1 | grep -Eq '^[0-9]+$'); then
    if [[ $1 -lt 0 || $1 -gt 100 ]]; then
      error "Please give a level between 0 - 100"
    fi
  else
    error "Please use only numbers"
  fi
}

## tests if arguments are not so close

test_diff() {
  if [[ ! $1 -gt $(($2 + 5)) ]]; then
    error "Please use [ --keep ] [ KEEP % ] for this"
  fi
}

## tests, and if found false,
## toggles the prop true

test_toggle() {
  if ! ($($1)); then
    set_prop $1 true
    echo -e "(!) $2 toggled ON\n"
  fi
}

## toggles the prop true / false

toggle() {
  if ($($1)); then
    value=false; status=OFF;
  else
    value=true; status=ON;
  fi

  echo -e "(i) Toggling $2 $status...\n"
  set_prop $1 $value
  echo -e "- Done\n"
}

## sets kernel switch properties

set_switch() {
  set_prop switch "$1 $2 $3"
  chown 0:0 $1; chmod 0644 $1;

  uevent=${1%/*}/uevent
  set_prop uevent $uevent
  chown 0:0 $uevent; chmod 0644 $uevent;
}

## turns charging ON / OFF

switch_() {
  c_ON=$(switch_f | awk '{print $2}')
  c_OFF=$(switch_f | awk '{print $3}')
  switch=$(switch_f | awk '{print $1}')
  
  if [[ $1 = ON ]]; then
    echo $c_ON >$switch
  else
    echo $c_OFF >$switch
  fi
}

## overrides daemon mode, if running

override_daemon() {
  if ($(daemon_mode)); then
    set_prop daemon_mode false
    echo -e "(!) Daemon mode overridden\n"
  fi
}

## tests, and updates up, down_threshold

update_cfg() {
  if [[ ! -z $2 ]]; then

    if [[ $1 -ge 15 && $2 -ge 15 ]]; then
      if [[ $1 -le 85 && $2 -le 85 ]]; then
        u=$1; d=$2;
      else gerror=true; fi
    else gerror=true; fi
  else

    if [[ $1 -gt 20 ]]; then
      if [[ $1 -le 85 ]]; then
        u=$1; if [[ $1 -ge 25 ]]; then
        d=$((u - 10)); else d=15; fi
      else gerror=true; fi
    else gerror=true; fi
  fi

  if [[ $gerror ]]; then
    error "These value/values affect battery life"
  fi

  set_prop up_threshold $u
  set_prop down_threshold $d
  echo -e "- New values saved\n"
}

## tests whether the device is charging

is_charging() { grep -q '^POWER_SUPPLY_STATUS=[Cc]harging$' $(uevent_f); }

# My realtime configuration set-up

uevent_f() { get_prop uevent; }

switch_f() { get_prop switch; }

auto_shut() { get_prop auto_shut; }

daemon_mode() { get_prop daemon_mode; }

do_ver_logging() { get_prop do_ver_logging; }

batt_level() { get_prop POWER_SUPPLY_CAPACITY $(uevent_f); }

up_threshold() { get_prop up_threshold; }

down_threshold() { get_prop down_threshold; }

shut_threshold() { get_prop shut_threshold; }

# This tests and sets references if compatible
# ( device must be charging throughout )

set_ctrl_refs() {
  echo -e "(!) Please make sure the device is charging\n"
  sleep 7

  ## get all possible references

  echo -e "(i) Checking compatibility...\n"
  if [[ ! -f $sys_cache ]]; then
    find /sys/devices -type f -name uevent 2>/dev/null | grep -E 'batt|charg' | sort >$sys_cache
  fi

  while read uevent; do

    ## cycling through all,
    ## get a matching uevent file

    if (grep -q '^POWER_SUPPLY_NAME=.*[Bb]att.*$' $uevent) \
    || (grep -q '^POWER_SUPPLY_NAME=.*[Uu][Ss][Bb].*$' $uevent) \
    || (grep -q '^POWER_SUPPLY_NAME=.*[Dd][Cc].*' $uevent); then
      set_prop uevent $uevent

      ## cycling through all,
      ## get a boolean switch

      for ref in ${uevent%/*}/*; do
      chown 0:0 $ref; chmod 644 $ref;

        case $(cat $ref) in
          1) echo 0 >$ref
            c_ON=1; c_OFF=0; ;;

          0) echo 1 >$ref
            c_ON=0; c_OFF=1; ;;

          on) echo off >$ref
            c_ON=on; c_OFF=off; ;;

          off) echo on >$ref
            c_ON=off; c_OFF=on; ;;

          true) echo false >$ref
            c_ON=true; c_OFF=false; ;;

          false) echo true >$ref
            c_ON=false; c_OFF=true; ;;

          enable) echo disable >$ref
            c_ON=enable; c_ON=disable; ;;

          disable) echo enable >$ref
            c_ON=disable; c_OFF=enable; ;;

          enabled) echo disabled >$ref
            c_ON=enabled; c_OFF=disabled; ;;

          disabled) echo enabled >$ref
            c_ON=disabled; c_OFF=enabled; ;;

          *) continue ;;
        esac; sleep 0.2;

        ## test if that works correctly,
        ## if yes break, else continue

        if ! (is_charging); then
          echo $c_ON >$ref; sleep 0.2;
          if (is_charging); then
            refs_found=true
            break 2
          fi
        fi
        echo $c_ON >$ref
      done
    fi
  done

  if [[ $refs_found ]]; then
    set_switch $ref $c_ON $c_OFF
    echo -e "- OK\n"
  else

    ## switch is not found,
    ## reset uevent, toggle daemon OFF

    set_prop uevent not_found_yet
    if ($(daemon_mode)); then
      set_prop daemon_mode false
      echo -e "(!) Daemon mode toggled OFF\n"
    fi
    error "Your kernel don't support this functionality"
  fi
}

# Function for [ --start / --stop ] [ % / time ]

charge() {
  if [[ $1 = start ]]; then
    turn_1=ON; turn_2=OFF; op=-lt; text=Charging; test='! is_charging';
  else
    turn_1=OFF; turn_2=ON; op=-gt; text=Discharging; test='is_charging';
  fi

  if [[ ! -z $2 ]]; then

    if (echo $2 | grep -Eq '^[0-9]+%$'); then
      threshold=$(echo $2 | tr -d '%')
      if [[ $threshold -lt 0 || $threshold -gt 100 ]]; then
        error "Please give a level between 0 - 100"
      fi
      override_daemon
      if (eval $test); then
        switch_ $turn_1
      fi

      echo -e "(i) $text until $threshold%...\n"
      while eval [[ \$\(batt_level\) $op \$threshold ]]; do
        if (eval $test); then
          switch_ $turn_1
        fi
        sleep 30
      done
      switch_ $turn_2

    elif (echo $2 | grep -Eq '^[0-9]+[smh]?$'); then
      override_daemon
      if (eval $test); then
        switch_ $turn_1
      fi

      echo -e "(i) $text until $2...\n"
      sleep $2
      switch_ $turn_2

    else
      error "Please give a valid argument"
    fi
  else

    override_daemon
    if (eval $test); then
      switch_ $turn_1
    fi
    echo -e "(i) $text now...\n"
  fi
}

# Disable logger

    set +x

# Verbose logger

if ($(do_ver_logging)); then
  if [[ $1 != --log ]]; then
    if [[ ! $no_logging ]]; then
      if [[ -f $ver_log ]]; then
        mv -f $ver_log $last_log
      fi
      echo -e "(!) Verbose logging is enabled\n"

      getprop | grep 'product' >$ver_log
      echo -e "\nmcc_version=$(get_prop versionCode $mod_dir/module.prop)\n" >>$ver_log
      set -x 2>>$ver_log
    fi
  fi
fi

# Set control references unless done

if [[ $(uevent_f) = not_found_yet ]]; then
  case $1 in

    --log            ) ;;
    --help           ) ;;
    --rconf          ) ;;
    --debug          ) ;;
    --breset         ) ;;
    --daemon_trigger ) ;;

    --daemon         ) if ! ($(daemon_mode)); then
            set_ctrl_refs 2>/dev/null; fi ;;
    --auto_shut      ) if ! ($(auto_shut)); then
            set_ctrl_refs 2>/dev/null; fi ;;

    *                ) set_ctrl_refs 2>/dev/null ;;
  esac
fi

case $1 in

## info

  --info)

    echo -e "- Battery status\n"
    echo "-- battery level :- $(batt_level)"
    echo "-- battery health :- $(get_prop POWER_SUPPLY_HEALTH $(uevent_f))"

    echo -e "-- charging status :- $(get_prop POWER_SUPPLY_STATUS $(uevent_f))\n"

    echo -e "- Current settings\n"
    echo "-- up threshold :- $(up_threshold)"
    echo "-- down threshold :- $(down_threshold)"
    echo -e "-- shut threshold :- $(shut_threshold)\n"
    echo "-- magisk daemon mode :- $(daemon_mode)"

    echo -e "-- automatic power-off :- $(auto_shut)\n"
      ;;

## manpage

  --help)

    while read line; do
      if [[ $line != '### Changelog' ]]; then
        echo "$line"
      else
        break
      fi
    done <$data_dir/README.md
      ;;

## re-test and configure kernel references

  --rconf)

    echo -e "(i) Re-configuring kernel references...\n"
    set_ctrl_refs 2>/dev/null
    echo -e "- Done\n"
      ;;

## debugging on demand, output in /cache

  --debug)

    echo -e "(i) Gathering ging data...\n"
    _zip=/cache/mcc_-"$(getprop ro.product.brand)-$(getprop ro.product.device)".zip
    rm -f "$_zip"

    $mod_dir/zip -9q "$_zip" /cache/mcc_debug_init.log 2>/dev/null
    for entry in $(find $mod_dir -type f); do
      if [[ $entry != $mod_dir/zip ]]; then
        $mod_dir/zip -9qu "$_zip" $entry 2>/dev/null
      fi
    done

    echo -e "- Done\n"
    echo -e "(!) Please upload $_zip to the official XDA thread\n"
      ;;

## reset battery stats

  --breset)

    echo -e "(i) Resetting battery statistics...\n"
    dumpsys batterysats --reset >/dev/null 2>&1

    if [[ $? -ne 0 ]]; then
      rm -f /data/system/batterystats.bin
    fi
    echo -e "- Done\n"
      ;;

## toggle verbose logging

  --log) toggle do_ver_logging "verbose logging"
      ;;

## toggle auto shut

  --auto_shut)

    toggle auto_shut "automatic power-off"
    if ($(auto_shut)); then
      test_toggle daemon_mode "Daemon mode"
    fi
      ;;

## toggle daemon mode

  --daemon) toggle daemon_mode "daemon mode"
      ;;

## keep battery level at certain level

  --keep)

    test_level $2
    override_daemon
    if ! (is_charging); then
      switch_ ON
    fi

    echo -e "(i) Battery level will be kept at $2%\n"
    while(:); do

      if [[ $(batt_level) -lt $2 ]]; then
        if ! (is_charging); then
          switch_ ON
        fi
      elif [[ $(batt_level) -gt $2 ]]; then
        if (is_charging); then
          switch_ OFF
        fi
      fi
      sleep 30
    done
      ;;

## enable charging (on demand/for certain %/time)

  --start) charge start $2
      ;;

## disable charging (on demand/for certain %/time)

  --stop) charge stop $2
      ;;

## trigger daemon ( MAGISK )

  --daemon_trigger)

    while(:); do

      if ($(auto_shut)); then
        if [[ $(batt_level) -le $(shut_threshold) ]]; then
          if ! (is_charging); then
            poweroff
          fi
        fi
      fi

      if ($(daemon_mode)); then
        if [[ $(batt_level) -ge $(up_threshold) ]]; then
          if (is_charging); then
            switch_ OFF
          fi

        elif [[ $(batt_level) -le $(down_threshold) ]]; then
          if ! (is_charging); then
            switch_ ON
          fi
        fi
      fi
      sleep 30
    done
      ;;

## back to defaults

  --defaults)

    set_prop shut_threshold 20
    set_prop up_threshold 70
    set_prop down_threshold 60
    echo -e "- Reverted all to defaults\n"
     ;;

## update auto shut threshold

  --shut)

    if (echo $2 | grep -Eq '^[0-9]+$'); then
      if [[ $2 -gt 20 || $2 -lt 5 ]]; then
        error "Please give a level between 5 - 20"
      fi
    else
      error "Please use only numbers"
    fi

    set_prop shut_threshold $2
    echo -e "- New value saved\n"
    test_toggle auto_shut "Automatic power-off"
      ;;

## update previous thresholds

  *)

    if [[ ! -z $2 ]]; then
      test_level $2; test_level $1;
      if [[ $2 -gt $1 ]]; then
        test_diff $2 $1; update_cfg $2 $1;
      else
        test_diff $1 $2; update_cfg $1 $2;
      fi

    elif [[ ! -z $1 ]]; then
      test_level $1; update_cfg $1;

    else
      set_prop up_threshold 70
      set_prop down_threshold 60
      echo -e "- Reverted to defaults, except for shut threshold\n"
    fi

    test_toggle daemon_mode "Daemon mode"
      ;;

esac
exit 0
